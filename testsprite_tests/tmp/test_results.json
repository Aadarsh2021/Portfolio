[
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "0459ff76-e366-4d26-b71e-deb27b17ecd1",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC001-Hero Section renders with animation and interactive elements",
    "description": "Verify that the Hero Section loads correctly with the animated introduction, profile image, call-to-action buttons, and social media links visible and functional.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Verify the call-to-action buttons are clickable and social media links navigate to correct URLs.\n        frame = context.pages[-1]\n        # Click 'Get In Touch' button to verify it is clickable\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section/div/div[2]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click 'Download Resume' button to verify it is clickable and triggers expected behavior.\n        frame = context.pages[-1]\n        # Click 'Download Resume' button to verify it is clickable and triggers download or navigation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section/div/div[2]/div/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Verify social media links for GitHub, LinkedIn, and Email are present and navigate to correct URLs.\n        frame = context.pages[-1]\n        # Click GitHub Profile link to verify it navigates to the correct URL\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section/div/div[2]/div/div/div/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click LinkedIn Profile link to verify it navigates to the correct URL\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section/div/div[2]/div/div/div/div[2]/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Click Email link to verify it opens the default mail client or mailto link\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section/div/div[2]/div/div/div/div[2]/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Hero Section Loaded Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The Hero Section did not load correctly with the animated introduction, profile image, call-to-action buttons, and social media links as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136438050242//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.405Z",
    "modified": "2025-11-26T05:53:58.202Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "57df631e-01bb-4c0c-b707-8ee4700ed789",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC002-About Section displays skills badges and timeline correctly",
    "description": "Validate that the About Section shows all skills as badges, educational background, and a professional experience timeline with interactive UI elements.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the About section link in the navigation menu to view the About section.\n        frame = context.pages[-1]\n        # Click on the About section link in the navigation menu\n        elem = frame.locator('xpath=html/body/div/div/div/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Interact with the professional experience timeline UI elements to confirm interactivity such as expand/collapse or highlight on user interaction.\n        frame = context.pages[-1]\n        # Click 'Read More â†’' button on the professional experience timeline to test interactivity\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[7]/section/div/div/div/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Confirm that the timeline highlights or collapses on further user interaction to fully validate interactive UI elements.\n        frame = context.pages[-1]\n        # Click the 'Read More' button again to test if the timeline collapses or changes highlight state on repeated interaction\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[7]/section/div/div/div/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        # Assert skills badges are displayed with proper labels and icons\n        await expect(frame.locator('text=Python').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=React.js').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Tailwind CSS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Machine Learning').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Deep Learning').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=TensorFlow').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PyTorch').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Scikit-learn').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pandas').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=NumPy').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=MySQL').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Git').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=GitHub').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Vercel').first).to_be_visible(timeout=30000)\n        # Assert educational background details are present\n        await expect(frame.locator('text=Bachelor of Technology (B.Tech)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=G L Bajaj Group of Institutions, Mathura').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Computer Science Engineering').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=12th Science (PCM)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Dashmesh Public School').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10th').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Holy Mary International School').first).to_be_visible(timeout=30000)\n        # Assert professional experience timeline is rendered with correct company names, dates, and achievements\n        await expect(frame.locator('text=Backend Developer Intern').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ASH-TECH SOLUTIONS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=07/2025 - Present').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Data Science Internship').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Internship Studio').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10/2024').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI-ML Virtual Internship').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AICTE').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=04/2024 - 06/2024').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Web Development Virtual Internship').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Bharat Intern').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10/2023 - 11/2023').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136604543131//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.412Z",
    "modified": "2025-11-26T05:56:44.734Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "1e701531-a120-4e1d-8f83-a8ec0b7ec6d8",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC003-Advanced Projects search and filter functionality",
    "description": "Ensure real-time search, category filtering, status indicators, and technology tags work correctly and update the project list without errors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on Projects section to open Advanced Projects section.\n        frame = context.pages[-1]\n        # Click on Projects section in the navigation menu to open Advanced Projects section\n        elem = frame.locator('xpath=html/body/div/div/div/div/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Locate the correct project search input field and type a keyword to test real-time search.\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Click on a category filter button (e.g., 'Web Apps') to test if the project list updates accordingly.\n        frame = context.pages[-1]\n        # Click on 'Web Apps' category filter button\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[5]/section/div/div/div[2]/div/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Clear search and filters to restore the full project list.\n        frame = context.pages[-1]\n        # Click 'Clear Filters' button to clear all filters and restore full project list\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[5]/section/div/div/div[3]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Test if the 'Featured Only' checkbox filter works correctly by toggling it and verifying the project list updates accordingly.\n        frame = context.pages[-1]\n        # Toggle 'Featured Only' checkbox filter to test if project list updates accordingly\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[5]/section/div/div/div[2]/div/div/div[2]/div[4]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Clear all filters to restore the full project list and verify no errors occur.\n        frame = context.pages[-1]\n        # Click 'Clear Filters' button to clear all filters and restore full project list\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[5]/section/div/div/div[3]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Smart City Traffic Monitoring').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Portfolio Website').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Farm-Ease').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=completed').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=React').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Node.js').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI-powered crop recommendation system with 95% accuracy').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136517383407//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.420Z",
    "modified": "2025-11-26T05:55:17.561Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "5df586fe-6ae5-4aa5-ae8e-844a157779f9",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC004-Certifications display with badges and valid verification links",
    "description": "Verify certification items show achievement badges and that clicking verification links opens a valid verification page.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to Certifications section by clicking the Certifications link in the navigation menu.\n        frame = context.pages[-1]\n        # Click on the Certifications section link in the navigation menu to navigate to Certifications.\n        elem = frame.locator('xpath=html/body/div/div/div/div/nav/a[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'View Certificate' button for the first certification to verify the verification link.\n        frame = context.pages[-1]\n        # Click on the 'View Certificate' button for the first certification (Data Science Certification) to open the verification page.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[6]/section/div/div/div/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'View Certificate' button for the second certification to check if its verification link works.\n        frame = context.pages[-1]\n        # Click on the 'View Certificate' button for the second certification (Machine Learning Internship) to test if the verification link opens a valid page.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[6]/section/div/div/div/div/div[2]/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Certification Achievement Unlocked').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Certification achievement badges are not visible or verification links do not open valid pages as expected in the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136121977801//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.427Z",
    "modified": "2025-11-26T05:48:42.109Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "a7296476-e6f4-4fe4-bb58-6b0f243c9a2e",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC005-Interactive Blog and Testimonials sections render and allow interaction",
    "description": "Confirm Blog posts and Testimonials are loaded, displayed properly, and test interactivity like pagination, opening full posts, and testimonial navigation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to Blog section by clicking Blog menu item\n        frame = context.pages[-1]\n        # Navigate to Blog section\n        elem = frame.locator('xpath=html/body/div/div/div/div/nav/a[7]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click to open the first full blog post by clicking its 'Read More' button\n        frame = context.pages[-1]\n        # Click 'Read More' on the first blog post to open full post\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[7]/section/div/div/div/div/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try clicking 'Read More' on the second blog post to see if it opens full content, or if that also fails, report the issue and stop.\n        frame = context.pages[-1]\n        # Click 'Read More' on the second blog post to attempt opening full post content\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[7]/section/div/div/div/div[2]/div/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Nonexistent Blog Post Title for Test Failure').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test plan execution failed: Blog posts and Testimonials did not load or display properly, or interactivity like pagination and navigation failed.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136293988182//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.434Z",
    "modified": "2025-11-26T05:51:34.153Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "596807e9-198c-4ab3-aa13-faeaeef2ccde",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC006-Contact Form submits with EmailJS, handles validation and errors",
    "description": "Test the contact form with valid and invalid inputs to verify form validation, EmailJS integration for message sending, and display of success/error notifications.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Navigate to Contact Form by clicking the Contact navigation link\n        frame = context.pages[-1]\n        # Click on Contact section link in the navigation menu to go to Contact Form\n        elem = frame.locator('xpath=html/body/div/div/div/div/nav/a[9]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Submit the contact form with all fields empty to check validation errors\n        frame = context.pages[-1]\n        # Click Send Message button with empty fields to trigger validation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[9]/section/div/div/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Fill the form with invalid email and incomplete information to check validation error messages\n        frame = context.pages[-1]\n        # Fill Name field with 'Test User'\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[9]/section/div/div/div/div/div/form/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        frame = context.pages[-1]\n        # Fill Email field with invalid email 'invalid-email'\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[9]/section/div/div/div/div/div/form/div[2]/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email')\n        \n\n        # -> Fill the form with valid inputs for all fields\n        frame = context.pages[-1]\n        # Correct Email field with valid email\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[9]/section/div/div/div/div/div/form/div[2]/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('valid.email@example.com')\n        \n\n        frame = context.pages[-1]\n        # Fill Subject field with valid subject\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[9]/section/div/div/div/div/div/form/div[3]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Subject')\n        \n\n        frame = context.pages[-1]\n        # Fill Message field with valid message\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[9]/section/div/div/div/div/div/form/div[4]/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('This is a test message for validation and EmailJS integration.')\n        \n\n        # -> Submit the form with valid inputs to verify EmailJS integration and success notification\n        frame = context.pages[-1]\n        # Click Send Message button to submit the form with valid inputs\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[9]/section/div/div/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=EmailJS Integration Successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The contact form validation, EmailJS message sending, or success/error notifications did not behave as expected according to the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136322934786//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.449Z",
    "modified": "2025-11-26T05:52:03.080Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "d331b05b-94e3-46b1-acf4-b8b7e7a52ff5",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC007-Dark/Light Theme Toggle respects system preference and persists choice",
    "description": "Test theme toggling functionality including system preference detection on initial load and persistence of user choice across sessions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Use the theme toggle button to switch to light theme\n        frame = context.pages[-1]\n        # Click the theme toggle button to switch to light theme\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Theme toggled to solar eclipse mode').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Theme toggling functionality did not work as expected. The site did not switch to the light theme or persist the user choice across sessions as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136158790777//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.461Z",
    "modified": "2025-11-26T05:49:18.914Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "b3bec4f1-4de6-4ca2-be84-a096b492954b",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC008-Progressive Web App offline support and install prompt",
    "description": "Validate service worker caching enables offline functionality and PWA install prompt appears and works as expected.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Open DevTools and simulate offline mode\n        frame = context.pages[-1]\n        # Click the button to switch to dark mode (to simulate interaction before offline test)\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the page\n        frame = context.pages[-1]\n        # Open Analytics Dashboard to simulate DevTools or related panel for offline simulation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the page to verify offline functionality\n        frame = context.pages[-1]\n        # Close Analytics Dashboard to prepare for offline reload\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the webpage to verify offline functionality\n        frame = context.pages[-1]\n        # Open Analytics Dashboard to simulate DevTools or related panel for offline simulation\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the webpage to verify offline functionality\n        frame = context.pages[-1]\n        # Close Analytics Dashboard modal to prepare for offline simulation\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the webpage to verify offline functionality\n        frame = context.pages[-1]\n        # Open Analytics Dashboard to simulate offline mode\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the webpage to verify offline functionality\n        frame = context.pages[-1]\n        # Close Analytics Dashboard modal to prepare for offline simulation\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the webpage to verify offline functionality\n        frame = context.pages[-1]\n        # Switch to light mode to simulate user interaction before offline test\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Open Analytics Dashboard to simulate offline mode\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the webpage to verify offline functionality\n        frame = context.pages[-1]\n        # Close Analytics Dashboard modal to prepare for offline simulation\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the webpage to verify offline functionality\n        frame = context.pages[-1]\n        # Switch to dark mode to simulate user interaction before offline test\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Open Analytics Dashboard to simulate offline mode\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the webpage to verify offline functionality\n        frame = context.pages[-1]\n        # Close Analytics Dashboard modal to prepare for offline simulation\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the webpage to verify offline functionality\n        frame = context.pages[-1]\n        # Switch to light mode to simulate user interaction before offline test\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Open Analytics Dashboard to simulate offline mode\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Simulate offline mode in DevTools and reload the webpage to verify offline functionality\n        frame = context.pages[-1]\n        # Close Analytics Dashboard modal to prepare for offline simulation\n        elem = frame.locator('xpath=html/body/div[3]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger the PWA install prompt and verify it appears to the user\n        frame = context.pages[-1]\n        # Click 'Get In Touch' button to simulate user interaction and potentially trigger PWA install prompt\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section/div/div[2]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Progressive Web App (PWA) with offline functionality').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Get In Touch').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136786873872//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.472Z",
    "modified": "2025-11-26T05:59:47.053Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "1ff1cdde-64eb-4902-bd6d-52572857ef45",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC009-SEO meta tags, structured data, and Open Graph tags are correctly implemented",
    "description": "Verify all essential SEO metadata, JSON-LD structured data, and Open Graph tags are present and valid for key pages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on About section link to load About page for SEO metadata verification\n        frame = context.pages[-1]\n        # Click on About section link to load About page\n        elem = frame.locator('xpath=html/body/div/div/div/div/nav/a[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Experience section link to load Experience page for SEO metadata verification\n        frame = context.pages[-1]\n        # Click on Experience section link to load Experience page\n        elem = frame.locator('xpath=html/body/div/div/div/div/nav/a[3]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on Skills section link to load Skills page for SEO metadata verification\n        frame = context.pages[-1]\n        # Click on Skills section link to load Skills page\n        elem = frame.locator('xpath=html/body/div/div/div/div/nav/a[4]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=SEO Metadata Verified Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Essential SEO metadata, JSON-LD structured data, and Open Graph tags verification did not pass as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136459506131//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.481Z",
    "modified": "2025-11-26T05:54:19.666Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "4e9ef668-ea9e-458b-aa7b-8add9f127c63",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC010-Accessibility compliance and ARIA attributes correctness",
    "description": "Check that all interactive components and pages meet WCAG standards with proper use of semantic HTML and ARIA attributes, supporting screen readers and keyboard navigation.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Portfolio').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Navigation Menu').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ðŸ ').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Home').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ðŸ‘¤').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=About').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ðŸ’¼').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Experience').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=âš¡').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Skills').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ðŸš€').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Projects').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ðŸ†').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Certifications').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ðŸ“').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Blog').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ðŸ’¬').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Testimonials').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ðŸ“§').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Contact').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AT').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ðŸ“Š').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Analytics').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Hi, I\\'m Aadarsh Thakur').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Full Stack Developer & Software Engineer').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=I craft exceptional digital experiences with modern technologies. Passionate about creating scalable solutions and bringing innovative ideas to life.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Get In Touch').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Download Resume').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=About Me').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=From a curious teenager who built his first \"Hello World\" program to a Computer Science Engineering Graduate and Backend Developer Intern at ASH-TECH SOLUTIONS, creating AI-powered solutions that impact real-world problems.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Started coding at 16 with Python, fascinated by how a few lines of code could solve complex problems. Built my first web scraper and was amazed by the power of automation.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Successfully graduated with Computer Science Engineering degree and joined ASH-TECH SOLUTIONS as a Backend Developer Intern, where I\\'m currently working on cutting-edge backend systems and gaining real-world industry experience.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Created Farm-Ease, an AI-powered agricultural platform that helps 200+ farmers increase crop yield by 30% through intelligent recommendations and blockchain-based supply chain transparency.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Today, as a Backend Developer Intern at ASH-TECH SOLUTIONS, I\\'m passionate about using technology to solve real-world problems, from smart city traffic management to sustainable agriculture. Every line of code is a step toward a better future.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Full Stack Development').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Experienced in building end-to-end web applications using modern technologies like React, Node.js, and cloud platforms.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Problem Solving').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Passionate about solving complex problems with clean, efficient code and innovative solutions that make a difference.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Performance Optimization').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Focused on creating fast, scalable applications with optimal user experience and cutting-edge performance.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Team Collaboration').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Strong believer in agile methodologies and collaborative development with excellent communication skills.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=DevOps & Automation').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Experienced with CI/CD pipelines, containerization, and cloud infrastructure for seamless deployment.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Continuous Learning').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Always exploring new technologies and best practices to stay current with the rapidly evolving tech landscape.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=My Journey').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=My journey in technology began with curiosity and has evolved into a passion for creating meaningful digital experiences. I believe in writing clean, maintainable code and staying updated with the latest industry trends.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=When I\\'m not coding, you\\'ll find me exploring new technologies, contributing to open-source projects, or sharing knowledge with the developer community.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Technical Skills').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Python').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=HTML').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=CSS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=React.js').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Tailwind CSS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Framer Motion').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Machine Learning').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Deep Learning').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=TensorFlow').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PyTorch').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Scikit-learn').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pandas').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=NumPy').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Matplotlib').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=MySQL').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Git').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=GitHub').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Vercel').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=50+').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=3+').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=15+').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=100%').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Backend Developer Intern').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ASH-TECH SOLUTIONS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=07/2025 - Present').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Developing REST APIs using Node.js and MongoDB').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Optimizing backend systems for improved scalability and performance').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Collaborating with development team on system architecture').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Implementing best practices for backend development').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Working on real-world projects with industry standards').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Data Science Internship').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Internship Studio').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10/2024').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Successfully completed Data Science Internship training, earning a Certificate of Completion.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Certificate Number: ISDSCT933504').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Gained hands-on experience in data analysis and visualization').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Completed comprehensive training in data science fundamentals').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI-ML Virtual Internship').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AICTE').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=04/2024 - 06/2024').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Successfully completed a 4-week AI and Machine Learning course.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Earned Course Completion and Internship Certificates from AICTE and EduSkills').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Gained hands-on experience with key AI concepts and technologies').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Developed practical skills in machine learning applications').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Web Development Virtual Internship').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Bharat Intern').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10/2023 - 11/2023').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Successfully completed a virtual internship program in Web Development.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Demonstrated skills in HTML, CSS, and JavaScript for frontend development').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Built responsive and interactive web applications').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Learned modern web development practices').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Bachelor of Technology (B.Tech)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=G L Bajaj Group of Institutions, Mathura').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2021 - 2025').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Major: Computer Science Engineering').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=CGPA: 6.5/10').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Data Structures').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Algorithms').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Database Management').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Web Development').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Machine Learning').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=12th Science (PCM)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Dashmesh Public School').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2021').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Scored: 75%').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Strong foundation in Physics, Chemistry, and Mathematics').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Active participation in technical events and competitions').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10th').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Holy Mary International School').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2018').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Scored: 75%').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Excellent academic performance').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Participated in various extracurricular activities').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Skills & Expertise').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=A comprehensive collection of my technical skills and expertise across various domains').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Programming Languages').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Python').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PROFICIENCY').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=JavaScript').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Web Development').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=HTML5').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=CSS3').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=React.js').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Tailwind CSS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Framer Motion').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Machine Learning (Supervised, Unsupervised)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Deep Learning').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Scikit-learn').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=TensorFlow').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PyTorch').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Model Training & Evaluation').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Computer Vision').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=OpenCV').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=YOLOv7').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ByteTrack').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Real-time Object Detection & Tracking').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Video Feed Analysis').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Data Science & Analytics').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pandas').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=NumPy').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Matplotlib').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Tools & Platforms').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Git').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=GitHub').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Vercel').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=50+').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Projects Completed').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=3+').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Years Experience').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=15+').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Technologies').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=100%').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Client Satisfaction').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Experience & Education').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Internships').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Backend Developer Intern').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ASH-TECH SOLUTIONS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=07/2025 - Present').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Currently working as a Backend Developer Intern at ASH-TECH SOLUTIONS, developing REST APIs and optimizing backend systems for scalability.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Developing REST APIs using Node.js and MongoDB').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Optimizing backend systems for improved scalability and performance').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Collaborating with development team on system architecture').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Implementing best practices for backend development').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Working on real-world projects with industry standards').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Data Science Internship').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Internship Studio').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10/2024').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Successfully completed Data Science Internship training, earning a Certificate of Completion.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Certificate Number: ISDSCT933504').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Gained hands-on experience in data analysis and visualization').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Completed comprehensive training in data science fundamentals').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AI-ML Virtual Internship').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=AICTE').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=04/2024 - 06/2024').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Successfully completed a 4-week AI and Machine Learning course.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Earned Course Completion and Internship Certificates from AICTE and EduSkills').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Gained hands-on experience with key AI concepts and technologies').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Developed practical skills in machine learning applications').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Web Development Virtual Internship').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Bharat Intern').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10/2023 - 11/2023').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Successfully completed a virtual internship program in Web Development.').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Demonstrated skills in HTML, CSS, and JavaScript for frontend development').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Built responsive and interactive web applications').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Learned modern web development practices').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Bachelor of Technology (B.Tech)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=G L Bajaj Group of Institutions, Mathura').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2021 - 2025').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Major: Computer Science Engineering').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ CGPA: 6.5/10').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Relevant Coursework: Data Structures, Algorithms, Database Management, Web Development, Machine Learning').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=12th Science (PCM)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Dashmesh Public School').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2021').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Scored: 75%').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Strong foundation in Physics, Chemistry, and Mathematics').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Active participation in technical events and competitions').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=10th').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Holy Mary International School').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=2018').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Scored: 75%').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Excellent academic performance').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=â€¢ Participated in various extracurricular activities').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Skills & Expertise').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=A comprehensive collection of my technical skills and expertise across various domains').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Programming Languages').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Python').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PROFICIENCY').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=JavaScript').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Web Development').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=HTML5').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=CSS3').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=React.js').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Tailwind CSS').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Framer Motion').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Machine Learning (Supervised, Unsupervised)').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Deep Learning').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Scikit-learn').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=TensorFlow').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=PyTorch').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Model Training & Evaluation').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Computer Vision').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=OpenCV').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=YOLOv7').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=ByteTrack').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Real-time Object Detection & Tracking').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Video Feed Analysis').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Data Science & Analytics').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Pandas').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=NumPy').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Matplotlib').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Tools & Platforms').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Git').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=GitHub').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Vercel').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136586005512//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.489Z",
    "modified": "2025-11-26T05:56:26.177Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "e1b8cfed-7873-4411-a1b9-301e9db38350",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC011-Animations and transitions perform smoothly without lag",
    "description": "Test all animations and transitions such as the particle background, section animations, and interactive UI elements for smooth performance and absence of jank.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2025-11-26T05:44:55.506Z",
    "modified": "2025-11-26T05:44:55.506Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "ec171a72-52d4-423f-91ec-4da057604736",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC012-Error boundary catches and handles runtime errors gracefully",
    "description": "Simulate errors in components and verify the Error Boundary component captures them and displays a user-friendly fallback UI without crashing the app.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Trigger a runtime error in a child component to test error boundary fallback UI.\n        frame = context.pages[-1]\n        # Click 'All Projects' button to navigate to projects section where error boundary can be tested.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[5]/section/div/div/div[2]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger a runtime error in a child component to test error boundary fallback UI.\n        frame = context.pages[-1]\n        # Click 'All Projects' button to ensure all projects are loaded and to trigger error in a child component if available.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[5]/section/div/div/div[2]/div/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to trigger a runtime error in a different child component or interaction to test error boundary fallback UI.\n        frame = context.pages[-1]\n        # Click 'Web Apps' filter button to try triggering a runtime error in a child component.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[5]/section/div/div/div[2]/div/div/div/div/button[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try to trigger a runtime error in a child component by interacting with a project card or other interactive element.\n        frame = context.pages[-1]\n        # Click 'View Source Code' link on the displayed project to try triggering a runtime error in a child component.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[5]/section/div/div/div[4]/div/div/div/div/div/div/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Error Boundary Fallback UI Activated').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The Error Boundary did not display the fallback UI after triggering a runtime error in a child component, indicating the app may have crashed or not handled the error properly.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136429795428//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.524Z",
    "modified": "2025-11-26T05:53:49.950Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "1b714d5e-f757-4f2d-ba3e-f2f46ef9932d",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC013-Notification system displays and dismisses toast messages correctly",
    "description": "Verify toast notifications appear on relevant user actions (e.g., form submissions) and can be dismissed manually or disappear automatically.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Fill and submit the contact form to trigger a success notification.\n        frame = context.pages[-1]\n        # Input name in contact form\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[9]/section/div/div/div/div/div/form/div[2]/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test User')\n        \n\n        # -> Scroll down and inspect the page for any toast notification elements or messages.\n        await page.mouse.wheel(0, 400)\n        \n\n        # -> Input invalid email only and submit the form to trigger error notification.\n        frame = context.pages[-1]\n        # Input invalid email to trigger error notification\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[9]/section/div/div/div/div/div/form/div[2]/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('invalid-email-format')\n        \n\n        frame = context.pages[-1]\n        # Click Send Message button to submit form with invalid data and trigger error notification\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/section[9]/section/div/div/div/div/div/form/div[2]/div[2]/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Notification: Operation completed successfully!').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Toast notifications did not appear or could not be verified as per the test plan steps for success and error notifications.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136575564975//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.532Z",
    "modified": "2025-11-26T05:56:15.733Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "379fdb5a-8fea-4892-9d8e-c438a3f17593",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC014-Mobile-first responsive design and collapsible mobile menu functionality",
    "description": "Check that the website renders optimally on mobile devices and the collapsible mobile navigation menu opens, closes, and navigates smoothly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Switch to mobile device emulator view to test mobile responsiveness and navigation menu\n        await page.goto('http://localhost:3000/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        frame = context.pages[-1]\n        # Click the button to switch to dark mode (if it affects mobile menu visibility)\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Mobile Menu Successfully Opened')).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The mobile navigation menu did not open, close, or navigate smoothly as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136207369896//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.541Z",
    "modified": "2025-11-26T05:50:07.553Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "0705127f-18e3-44af-9f9b-3def20b12029",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC015-Performance monitoring reports web vitals and displays analytics modal",
    "description": "Validate that performance metrics such as First Contentful Paint, Largest Contentful Paint, and Cumulative Layout Shift are correctly tracked and the analytics dashboard modal presents this data.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click the 'Analytics' button to open the analytics dashboard modal.\n        frame = context.pages[-1]\n        # Click the 'Analytics' button to open the analytics dashboard modal.\n        elem = frame.locator('xpath=html/body/div/div/div/div/div/nav/div/div[2]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Page Views').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Session Duration').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Load Time').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Initial page load').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Performance').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136138676113//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.548Z",
    "modified": "2025-11-26T05:48:58.874Z"
  },
  {
    "projectId": "a832cab0-c3b4-4137-9295-30733974b9f5",
    "testId": "49d84c9c-d5a4-4be2-9f7b-1936a2819892",
    "userId": "3438f478-e071-7006-2c8b-2c0394ac6725",
    "title": "TC016-Image optimization and lazy loading function correctly",
    "description": "Confirm that images are loaded lazily as they enter the viewport and optimized image components serve appropriate resolutions without layout shifts.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:3000/\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Click on the Projects section link to navigate to a page with multiple images.\n        frame = context.pages[-1]\n        # Click on Projects section link to navigate to a page with multiple images\n        elem = frame.locator('xpath=html/body/div/div/div/div/nav/a[5]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Scroll down the Projects page to check if images outside the viewport are not loaded immediately.\n        await page.mouse.wheel(0, 800)\n        \n\n        # -> Scroll further down the page slowly to observe images loading as they enter the viewport and monitor for layout shifts.\n        await page.mouse.wheel(0, 400)\n        \n\n        # -> Scroll slowly further down the Projects page to observe images loading as they come into view and monitor for any layout shifts or delays.\n        await page.mouse.wheel(0, 400)\n        \n\n        # -> Inspect network requests to confirm if images are served in optimized sizes and check for layout shifts during image loading.\n        await page.goto('http://localhost:3000/#projects', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        await expect(frame.locator('text=Smart City Traffic Monitoring').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Portfolio Website').first).to_be_visible(timeout=30000)\n        await expect(frame.locator('text=Farm-Ease').first).to_be_visible(timeout=30000)\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/3438f478-e071-7006-2c8b-2c0394ac6725/1764136384208189//tmp/test_task/result.webm",
    "created": "2025-11-26T05:44:55.556Z",
    "modified": "2025-11-26T05:53:04.414Z"
  }
]
